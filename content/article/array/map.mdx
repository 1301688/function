---
title: "配列すべての要素に処理を加えたいとき"
date: "2021-08-29T21:51:53Z"
updateDate: ""
category: "array"
tags: "array"
description: "Array.prototype.map( )"
emoji: "🙂"
topImage: ""
---

# はじめに、なぜそうなったのか？から学べばキャッチアップしやすい

# 結論

- map( )を使用する

- map とは
  - 与えられた関数を配列のすべての要素に対して一度づつ呼び出し、その結果から新しい配列を生成する為に使用する
  - もとの配列を変更せず、同じサイズの新しい配列を返す非破壊的メゾット
  - 新しい配列を作成するので、返された配列を使わない場合、map を使うのはパターンに合わない 代わりに forEach または for-of を使用する
  - 関数型プログラミングを行うにあたって非常に重要なメゾット

# ユースケース

- 配列の要素それぞれに何かしらを追加して返却する

  - const plusFunction = 対象となる配列.map(なんでも引数 => `${なんでも引数} 追加したい何かしら`)

- 文字列配列をオブジェクト配列に変換して返却する

  - const objectFunction = 対象となる配列.map(なんでも引数 => ({ オブジェクト key : なんでも引数 })

- 配列の要素を更新して新しい配列を返却する

  - const editName = (oldName, name, arr) =>
    　　　 arr.map((item) => (item.name === oldName ? { ...item, name } : item));
  - const updatedSchools = editName(以前の要素, 新しい要素, 対象の配列);

- オブジェクトから配列に変換して返却する

  - const familys = {isao: 37,arisa: 37,yamato: 15,iroha: 12,neiro: 9,};
  - const familysArray = Object.keys(familys).map((key) => ({name: key,old: familys[key],}));

# 使用すべきではないケース

- 返された配列を使用しない場合
- コールバックから値を返さない場合

# 今回の目的　達成したい箇所 ユースケース

- map()を使いこなせるようになる
- ユースケースを書き出す
- 当該関数を使ってプログラムが書けることを常態化する

# 問題　理解できていない箇所

- 式のアルゴリズム
- 書き方

# 解決策　対策手順の概要

- 参考サイト調査
- わからない時はコピペでも良いからとにかく PDCA を回す
- 場数をふやす-

# 目的達成手順　順序立てた目的達成手順

- 1.場数を増やす
- 2.使用傾向を集める
- 3.データが集まったら集中学習する
- 4.当該関数を使って小さいプログラムを作る

# まとめ　ポジティブ意見

- map()は頻出メゾットかつ幅広く活用、応用できる
- 難しいので完全な理解をするためコツコツ場数を増やしてモノのする

# 自分がわからないと意味がないので自分の言葉でアウトプットすること

---

## 構成２　内向けの場合

1. 記事構成（記事構成）
2. 目的（解決したい問題）結論から宣言する
3. 解決策（対策手順の概要）
4. ユースケースのイメージ（ストーリーこれ ② かも）
5. 説明と理由（手順を段階的に）（理由を書くとイメージがさらに UP する）（関連記事へのリンク＝自分用、関連記事への後記＝稼ぎ用）
6. 実習（コード挿入）
7. まとめ　まとめるならポジティブ　まとめないケースもあるマナブさん
8. 稼ぐ要素を必ず添付
9. 応用リンク（⑤ の説明の後記）

---

## ひとつひとつ理解するための大義、フレームワーク

1. 目的と issue 本当に達成すべきか
2. 問題と改善 どのような問題を解決してくれるか
3. 基本の使い方 基本的な使い方だけ書く
4. 応用の使い方 応用して使うにはどのような知識を持っておけば良いかだけ書く
   ※前提として 1,2 のみで大枠だけ書くだけ
   ※応用は改善時に学習しないと定着不可能のため

---

## 下記自分ルール　これだけくりかえし

1. 選択と集中 選択が出来たところで無意味　意味あるものに集中して有意味　（自問:issue）
2. 理解と説明 理解できたところで無意味　難しいことをカンタンに説明ができる事で有意味 (自己理解:自分の言葉)
3. 施行と改善 施行を続けたところで無意味　施行ありきの改善を続けることで有意味 (自己改善:アップデート)

---
