---
title: "配列から単一の値やオブジェクトに変換したいとき"
date: "2021-09-02T07:26:30Z"
updateDate: ""
category: "array"
tags: "array"
description: "Array.prototype.reduce( )"
emoji: "🙂"
topImage: ""
---

# はじめに、なぜそうなったのか？から学べばキャッチアップしやすい

# 結論

- reduce( )を使用する

- reduce とは
  - 配列の要素に対して処理を実行し、その結果から新しい値を生成する為に使用する
  - 配列の各要素に対して（引数で与えられた）reducer 関数を実行して単一の値を返却するメゾット
  - 配列の要素から「最大値・最小値・重複値・特定値」などを返却したい時に使用することが多い

# 自分が理解できたドキュメントが必ず存在するから

# 構文

- arr.reduce(callback( accumulator, currentValue[, index[, array]] ) {
  // return result from executing something for accumulator or currentValue
  }[, initialValue]);
- 引数
- callback

  - 配列のすべての要素 (initialValue が提供されなかった場合は、最初を除く) に対して実行される関数です。

- これは 4 つの引数を取ります。

- accumulator
  - callback の返値を蓄積するアキュームレーターです。これは、コールバックの前回の呼び出しで返された値、あるいは initialValue が指定されている場合はその値となります (以下を参照ください)。
- currentValue
  - 現在処理されている配列の要素です。
- index 省略可
  - 現在処理されている配列要素のインデックスです。initialValue が指定された場合はインデックス 0 から、そうでない場合はインデックス 1 から開始します。
- array 省略可
  - reduce() が呼び出された配列です。
- initialValue 省略可
  - callback の最初の呼び出しの最初の引数として使用する値。initialValue が与えられなかった場合、配列の最初の要素がアキュムレーターの初期値として使用され、currentValue としてスキップされます。空の配列に対して reduce() を呼び出した際、initialValue が指定されていないと TypeError が発生します。
- 第一引数はコールバック関数で第二引数はコールバック関数の最初の呼び出し時に渡される初期値

# ユースケース

- 配列の中から最大値を見つける

```
const ages = [37, 36, 15, 67, 12, 62, 9];
const maxAge = ages.reduce((max, age) => {
console.log(`${age} > ${max} = ${age > max}`);
if (age > max) {
  return age;
} else {
  return max;
}
}, 0);
```

- 配列をオブジェクトに変換する

```
const colors = [
{
  id: "xekare",
  title: "red red",
  reting: 3,
},
{
  id: "jbwsof",
  title: "big blue",
  reting: 2,
},
{
  id: "prigbj",
  title: "grizzly grey",
  reting: 5,
},
{
  id: "ryhbhsl",
  title: "banana",
  reting: 1,
},
];
```

```
const hashColors = colors.reduceRight((hash, { id, title, rating }) => {
hash[id] = { title, rating };
return hash;
}, {});

```

- 配列から全く異なる配列に変換する

```
const colors = ["red", "red", "green", "blue", "green"];

const uniqueColors = colors.reduce(
  (unique, color) =>
    unique.indexOf(color) !== -1 ? unique : [...unique, color],
  []
);
```

# 今回の目的　達成したい箇所 ユースケース

- reduce()を使いこなす
- ユースケースを書き出す

# 問題　理解できていない箇所

- 式のアルゴリズム
- 書き方

# 解決策　対策手順の概要

- 参考サイト調査
- わからない時はコピペでも良いからとにかく PDCA を回す
- 場数をふやす

# 目的達成手順　順序立てた目的達成手順

- 1.場数を増やす
- 2.使用傾向を集める
- 3.データが集まったら集中学習する

# まとめ　ポジティブ意見

- reduce()は頻出メゾットかつ幅広く活用、応用できる
- 難しいので完全な理解をするためコツコツ場数を増やしてモノのする

# 自分がわからないと意味がないので自分の言葉でアウトプットすること

---

## 構成２　内向けの場合

1. 記事構成（記事構成）
2. 目的（解決したい問題）結論から宣言する
3. 解決策（対策手順の概要）
4. ユースケースのイメージ（ストーリーこれ ② かも）
5. 説明と理由（手順を段階的に）（理由を書くとイメージがさらに UP する）（関連記事へのリンク＝自分用、関連記事への後記＝稼ぎ用）
6. 実習（コード挿入）
7. まとめ　まとめるならポジティブ　まとめないケースもあるマナブさん
8. 稼ぐ要素を必ず添付
9. 応用リンク（⑤ の説明の後記）

---

## ひとつひとつ理解するための大義、フレームワーク

1. 目的と issue 本当に達成すべきか
2. 問題と改善 どのような問題を解決してくれるか
3. 基本の使い方 基本的な使い方だけ書く
4. 応用の使い方 応用して使うにはどのような知識を持っておけば良いかだけ書く
   ※前提として 1,2 のみで大枠だけ書くだけ
   ※応用は改善時に学習しないと定着不可能のため

---

## 下記自分ルール　これだけくりかえし

1. 選択と集中 選択が出来たところで無意味　意味あるものに集中して有意味　（自問:issue）
2. 理解と説明 理解できたところで無意味　難しいことをカンタンに説明ができる事で有意味 (自己理解:自分の言葉)
3. 施行と改善 施行を続けたところで無意味　施行ありきの改善を続けることで有意味 (自己改善:アップデート)

---
